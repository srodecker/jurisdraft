<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JurisDraft - Legal Workspace</title>
    <link rel="stylesheet" href="/css/tailwind.css" />
    <style>
        * { box-sizing: border-box; }
        html, body { 
            height: 100vh; 
            margin: 0; 
            overflow: hidden; 
        }
        .workspace-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        .sidebar {
            width: 400px;
            min-width: 400px;
            height: 100vh;
            overflow-y: auto;
            background: #ffffff;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
        }
        .dark .sidebar {
            background: #1e293b;
            border-right-color: #334155;
        }
        .main-workspace {
            flex: 1;
            height: 100vh;
            background: #f1f5f9;
            display: flex;
            flex-direction: column;
        }
        .dark .main-workspace {
            background: #0f172a;
        }
        .pdf-container {
            flex: 1;
            width: 100%;
            height: 100%;
        }
        .pdf-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
        }
        .dark .sidebar-section {
            border-bottom-color: #334155;
        }
        .sidebar-section:last-child {
            border-bottom: none;
        }
        /* Custom scrollbar for sidebar */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        .dark .sidebar::-webkit-scrollbar-thumb {
            background: #475569;
        }
        .btn-primary {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 12px 20px;
            background: #3758f9;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn-primary:hover:not(:disabled) {
            background: #2748e8;
        }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-secondary {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 12px 20px;
            background: #6366f1;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn-secondary:hover:not(:disabled) {
            background: #4f46e5;
        }
        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-download {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            padding: 12px 16px;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            font-size: 13px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .btn-download:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-orange { background: #f97316; }
        .btn-orange:hover:not(:disabled) { background: #ea580c; }
        .btn-green { background: #22c55e; }
        .btn-green:hover:not(:disabled) { background: #16a34a; }
        
        .form-select, .form-textarea {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #f9fafb;
            font-size: 14px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .dark .form-select, .dark .form-textarea {
            background: #1e293b;
            border-color: #334155;
            color: #e2e8f0;
        }
        .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #3758f9;
            box-shadow: 0 0 0 3px rgba(55, 88, 249, 0.1);
        }
        .form-textarea {
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            resize: none;
        }
        .drop-zone {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #3758f9;
            background: #eff6ff;
        }
        .dark .drop-zone {
            border-color: #475569;
        }
        .dark .drop-zone:hover, .dark .drop-zone.dragover {
            border-color: #3758f9;
            background: rgba(55, 88, 249, 0.1);
        }
        .file-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: #f1f5f9;
            border-radius: 8px;
            margin-top: 8px;
        }
        .dark .file-card {
            background: #334155;
        }
        .file-card-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #3758f9;
            color: white;
            border-radius: 6px;
            flex-shrink: 0;
        }
        .file-card-info {
            flex: 1;
            min-width: 0;
        }
        .file-card-name {
            font-size: 13px;
            font-weight: 500;
            color: #1e293b;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .dark .file-card-name {
            color: #e2e8f0;
        }
        .file-card-size {
            font-size: 11px;
            color: #64748b;
        }
        .status-box {
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            margin-top: 12px;
        }
        .status-success {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #86efac;
        }
        .dark .status-success {
            background: rgba(34, 197, 94, 0.1);
            color: #86efac;
            border-color: rgba(34, 197, 94, 0.3);
        }
        .status-error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }
        .dark .status-error {
            background: rgba(239, 68, 68, 0.1);
            color: #fca5a5;
            border-color: rgba(239, 68, 68, 0.3);
        }
        .status-info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }
        .dark .status-info {
            background: rgba(59, 130, 246, 0.1);
            color: #93c5fd;
            border-color: rgba(59, 130, 246, 0.3);
        }
        .pdf-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #94a3b8;
        }
        .pdf-placeholder svg {
            width: 80px;
            height: 80px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .field-stats {
            display: inline-flex;
            align-items: center;
            padding: 4px 12px;
            background: #eff6ff;
            color: #3758f9;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }
        .dark .field-stats {
            background: rgba(55, 88, 249, 0.1);
        }
        .tip-box {
            background: #eff6ff;
            border-left: 4px solid #3758f9;
            padding: 12px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
            color: #475569;
        }
        .dark .tip-box {
            background: rgba(55, 88, 249, 0.1);
            color: #94a3b8;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-dark">
    <div class="workspace-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Header -->
            <div class="sidebar-section" style="padding: 16px 20px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="width: 36px; height: 36px; background: #3758f9; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                        <svg width="20" height="20" fill="white" viewBox="0 0 24 24">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                            <polyline points="14 2 14 8 20 8" fill="none" stroke="white" stroke-width="2"/>
                        </svg>
                    </div>
                    <div>
                        <h1 style="font-size: 18px; font-weight: 700; color: #1e293b; margin: 0;">JurisDraft</h1>
                        <p style="font-size: 11px; color: #64748b; margin: 0;">Legal Workspace</p>
                    </div>
                </div>
            </div>

            <!-- Extract Section -->
            <div class="sidebar-section">
                <h2 style="font-size: 13px; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;">
                    üì§ Extract Data
                </h2>
                
                <div id="drop" class="drop-zone">
                    <svg style="width: 32px; height: 32px; margin: 0 auto 8px; color: #3758f9;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    <p style="font-size: 13px; color: #64748b; margin-bottom: 8px;">Drop files or click to select</p>
                    <button id="selectBtn" type="button" style="padding: 6px 14px; background: #3758f9; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer;">
                        Select Files
                    </button>
                </div>

                <input id="fileInput" type="file" multiple style="display:none" />
                <div id="filesList"></div>

                <button id="uploadBtn" disabled class="btn-primary" style="margin-top: 12px;">
                    <span id="uploadBtnText">Upload & Extract</span>
                </button>

                <div id="extractNote"></div>
            </div>

            <!-- Template Selection -->
            <div class="sidebar-section">
                <h2 style="font-size: 13px; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;">
                    üìã Template
                </h2>
                <select id="templateSelect" class="form-select">
                    <option value="">Loading templates...</option>
                </select>
            </div>

            <!-- JSON Input -->
            <div class="sidebar-section" style="flex: 1;">
                <h2 style="font-size: 13px; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;">
                    üìù JSON Data
                </h2>
                <textarea id="jsonInput" class="form-textarea" rows="10" placeholder='Enter JSON data, e.g.:
{
  "firstName": "John",
  "lastName": "Doe",
  "email": "john@example.com"
}'></textarea>
                
                <div class="tip-box" style="margin-top: 12px;">
                    <strong>üí° Tip:</strong> Field names in your JSON should match the form field names in the PDF.
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="sidebar-section">
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <button id="fillBtn" disabled class="btn-primary">
                        <span id="fillBtnText">Generate PDF</span>
                    </button>
                    
                    <button id="autoFillBtn" disabled class="btn-secondary">
                        Auto Test Fill
                    </button>

                    <button id="submitBtn" disabled class="btn-secondary">
                        Submit Additional JSON
                    </button>

                    <div style="display: flex; gap: 8px; margin-top: 4px;">
                        <button id="downloadBtn" disabled class="btn-download btn-orange">
                            <svg style="width: 16px; height: 16px; margin-right: 6px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                            Download
                        </button>
                        <button id="downloadCourtBtn" disabled class="btn-download btn-green">
                            <svg style="width: 16px; height: 16px; margin-right: 6px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            Court Ready
                        </button>
                    </div>
                </div>

                <div id="statusMessage"></div>
                <div id="fieldStats" style="margin-top: 12px; text-align: center;"></div>
            </div>
        </aside>

        <!-- Main PDF Workspace -->
        <main class="main-workspace">
            <div id="pdfViewer" class="pdf-container">
                <div class="pdf-placeholder">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    <p style="font-size: 16px; font-weight: 500;">PDF Preview</p>
                    <p style="font-size: 13px; margin-top: 4px;">Select a template and click "Generate PDF" to preview</p>
                </div>
            </div>
        </main>
    </div>

    <script>
    // ===== EXTRACT FUNCTIONALITY =====
    const drop = document.getElementById('drop');
    const fileInput = document.getElementById('fileInput');
    const selectBtn = document.getElementById('selectBtn');
    const filesList = document.getElementById('filesList');
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadBtnText = document.getElementById('uploadBtnText');
    const extractNote = document.getElementById('extractNote');

    let files = [];

    selectBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        fileInput.click();
    });
    
    drop.addEventListener('click', () => fileInput.click());
    
    fileInput.addEventListener('change', (e) => handleFiles(Array.from(e.target.files)));

    ['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, (e) => {
        e.preventDefault(); 
        e.stopPropagation(); 
        drop.classList.add('dragover');
    }));
    
    ['dragleave','drop'].forEach(ev => drop.addEventListener(ev, (e) => {
        e.preventDefault(); 
        e.stopPropagation(); 
        drop.classList.remove('dragover');
    }));

    drop.addEventListener('drop', (e) => {
        const dt = e.dataTransfer;
        if (dt && dt.files) {
            handleFiles(Array.from(dt.files));
        }
    });

    function handleFiles(newFiles) {
        for (const f of newFiles) {
            const key = f.name + ":" + f.size;
            if (!files.some(x => x._key === key)) {
                f._key = key;
                files.push(f);
            }
        }
        renderFiles();
    }

    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const icons = {
            pdf: 'üìÑ',
            doc: 'üìù', docx: 'üìù',
            txt: 'üìÉ',
            jpg: 'üñºÔ∏è', jpeg: 'üñºÔ∏è', png: 'üñºÔ∏è', gif: 'üñºÔ∏è',
            xls: 'üìä', xlsx: 'üìä', csv: 'üìä'
        };
        return icons[ext] || 'üìé';
    }

    function renderFiles() {
        filesList.innerHTML = '';
        files.forEach((f, i) => {
            const el = document.createElement('div');
            el.className = 'file-card';
            el.innerHTML = `
                <div class="file-card-icon">
                    <span style="font-size: 16px;">${getFileIcon(f.name)}</span>
                </div>
                <div class="file-card-info">
                    <div class="file-card-name">${escapeHtml(f.name)}</div>
                    <div class="file-card-size">${formatFileSize(f.size)}</div>
                </div>
                <button data-i="${i}" class="remove" style="background: none; border: none; color: #ef4444; cursor: pointer; padding: 4px 8px; font-size: 12px;">
                    ‚úï
                </button>
            `;
            filesList.appendChild(el);
        });
        
        Array.from(filesList.querySelectorAll('.remove')).forEach(btn => {
            btn.addEventListener('click', (e) => {
                const i = Number(e.target.getAttribute('data-i'));
                files.splice(i, 1);
                renderFiles();
            });
        });
        
        uploadBtn.disabled = files.length === 0;
    }

    function escapeHtml(s) { 
        return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); 
    }

    uploadBtn.addEventListener('click', async () => {
        if (files.length === 0) return;
        
        uploadBtn.disabled = true; 
        uploadBtnText.innerHTML = '<span style="display: inline-block; width: 14px; height: 14px; border: 2px solid white; border-top-color: transparent; border-radius: 50%; margin-right: 8px;" class="animate-spin"></span>Extracting...';
        showExtractStatus('Uploading and extracting...', 'info');

        const form = new FormData();
        for (const f of files) form.append('files', f, f.name);

        try {
            const res = await fetch('/api/extract', { method: 'POST', body: form });

            const contentType = res.headers.get('content-type') || '';
            let data;
            if (contentType.includes('application/json')) {
                data = await res.json();
            } else {
                const text = await res.text();
                console.error('Non-JSON response from /api/extract:', text);
                
                // Check if this is a Vercel/hosting platform timeout error
                if (res.status === 503 && (text.includes('deployment is currently unavailable') || text.includes('SERVICE_UNAVAILABLE') || text.includes('sfo1::') || text.includes('iad1::') || text.includes('hnd1::'))) {
                    throw new Error('The request timed out. This can happen with complex documents that take longer to process. Please try:\n1. Breaking the document into smaller parts\n2. Using a simpler/cleaner image\n3. Trying again in a few moments');
                }
                
                throw new Error('Server returned non-JSON response. Check console.');
            }

            if (!res.ok) throw new Error(data.error || 'Extraction failed');

            if (data.generated) {
                let txt = data.generated;
                let jsonString = null;
                
                try { 
                    jsonString = JSON.parse(txt); 
                } catch (e) {
                    const match = txt.match(/\{[\s\S]*\}/m);
                    if (match) {
                        try { jsonString = JSON.parse(match[0]); }
                        catch (ee) { /* fall through */ }
                    }
                }

                if (jsonString && jsonString.error) {
                    console.error('Gemini API Error:', jsonString.error);
                    showExtractStatus(`API Error: ${escapeHtml(jsonString.error.message || 'Unknown error')}`, 'error');
                    uploadBtn.disabled = false;
                    uploadBtnText.textContent = 'Upload & Extract';
                    return;
                }

                if (jsonString) {
                    jsonInput.value = JSON.stringify(jsonString, null, 2);
                    showExtractStatus('Data extracted successfully! Now fill out the PDF form.', 'success');
                    
                    uploadBtn.disabled = false;
                    uploadBtnText.textContent = 'Upload & Extract';
                    
                    files = [];
                    renderFiles();
                    return;
                }

                showExtractStatus('Warning: The model returned text that is not valid JSON.', 'error');
                uploadBtn.disabled = false;
                uploadBtnText.textContent = 'Upload & Extract';
                return;
            }

            const preview = data.promptPreview ? data.promptPreview : JSON.stringify(data.files || data, null, 2);
            jsonInput.value = JSON.stringify({ note: data.note || 'No API key', preview }, null, 2);
            showExtractStatus('Data prepared (no API key detected)', 'info');

        } catch (err) {
            console.error(err);
            showExtractStatus(`Error: ${escapeHtml(err.message)}`, 'error');
        } finally {
            uploadBtn.disabled = false;
            uploadBtnText.textContent = 'Upload & Extract';
        }
    });

    function showExtractStatus(message, type = 'info') {
        extractNote.innerHTML = `<div class="status-box status-${type}">${message}</div>`;
    }

    // ===== PDF FILL FUNCTIONALITY =====
    const templateSelect = document.getElementById('templateSelect');
    const jsonInput = document.getElementById('jsonInput');
    const fillBtn = document.getElementById('fillBtn');
    const fillBtnText = document.getElementById('fillBtnText');
    const submitBtn = document.getElementById('submitBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const downloadCourtBtn = document.getElementById('downloadCourtBtn');
    const pdfViewer = document.getElementById('pdfViewer');
    const statusMessage = document.getElementById('statusMessage');
    const fieldStats = document.getElementById('fieldStats');
    const autoFillBtn = document.getElementById('autoFillBtn');

    let currentPDFData = null;
    let currentPDFUrl = null;

    async function loadTemplates() {
        try {
            const response = await fetch('/api/templates');
            const data = await response.json();
            
            templateSelect.innerHTML = '<option value="">-- Select a PDF Template --</option>';
            
            if (data.templates && data.templates.length > 0) {
                data.templates.forEach(template => {
                    const option = document.createElement('option');
                    option.value = template;
                    option.textContent = template;
                    templateSelect.appendChild(option);
                });
            } else {
                templateSelect.innerHTML = '<option value="">No templates found</option>';
                showStatus('No PDF templates found in the templates folder', 'error');
            }
        } catch (error) {
            console.error('Error loading templates:', error);
            showStatus('Failed to load templates', 'error');
            templateSelect.innerHTML = '<option value="">Error loading templates</option>';
        }
    }

    templateSelect.addEventListener('change', () => {
        const hasTemplate = !!templateSelect.value;
        fillBtn.disabled = !hasTemplate;
        autoFillBtn.disabled = !hasTemplate;
    });

    async function fillPDF() {
        const templateName = templateSelect.value;
        const jsonData = jsonInput.value.trim();

        if (!templateName) {
            showStatus('Please select a PDF template', 'error');
            return;
        }

        if (!jsonData) {
            showStatus('Please enter JSON data', 'error');
            return;
        }

        try {
            JSON.parse(jsonData);
        } catch (e) {
            showStatus('Invalid JSON format: ' + e.message, 'error');
            return;
        }

        fillBtn.disabled = true;
        fillBtnText.innerHTML = '<span style="display: inline-block; width: 14px; height: 14px; border: 2px solid white; border-top-color: transparent; border-radius: 50%; margin-right: 8px;" class="animate-spin"></span>Processing...';
        showStatus('Processing PDF...', 'info');

        try {
            const response = await fetch('/api/fill-pdf', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    templateName,
                    jsonData
                })
            });

            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.error || 'Failed to fill PDF');
            }

            currentPDFData = result.pdfData;

            if (currentPDFUrl) {
                URL.revokeObjectURL(currentPDFUrl);
            }

            const blob = base64ToBlob(result.pdfData, 'application/pdf');
            currentPDFUrl = URL.createObjectURL(blob);
            pdfViewer.innerHTML = `<iframe src="${currentPDFUrl}"></iframe>`;

            showStatus(`PDF filled successfully! ${result.filledFields} of ${result.totalFields} fields filled.`, 'success');

            let fieldStatsHTML = `<span class="field-stats">${result.filledFields}/${result.totalFields} fields filled</span>`;
            
            if (result.processedData && result.processedData['[ZIP_NOT_FOUND]'] === true) {
                const debtorZip = result.processedData['[DEBTOR1_ZIP]'] || 'unknown';
                fieldStatsHTML += `<br><span class="field-stats" style="background: #fef2f2; color: #ef4444; margin-top: 8px;">‚ö†Ô∏è Zip ${debtorZip} not found</span>`;
            }
            
            fieldStats.innerHTML = fieldStatsHTML;

            // Enable download buttons
            downloadBtn.disabled = false;
            downloadCourtBtn.disabled = false;
            submitBtn.disabled = false;

            if (result.availableFields && result.availableFields.length > 0) {
                console.log('Available form fields:');
                result.availableFields.forEach(field => {
                    console.log(`- ${field.name} (${field.type})`);
                });
            }
        } catch (error) {
            console.error('Error filling PDF:', error);
            showStatus('Error: ' + error.message, 'error');
        } finally {
            fillBtn.disabled = false;
            fillBtnText.textContent = 'Generate PDF';
        }
    }

    async function autoFillPDF() {
        const templateName = templateSelect.value;

        if (!templateName) {
            showStatus('Please select a PDF template', 'error');
            return;
        }

        autoFillBtn.disabled = true;
        showStatus('Running auto test fill...', 'info');

        try {
            const response = await fetch('/api/auto-fill-pdf', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ templateName })
            });

            const result = await response.json();

            if (!response.ok || !result.success) {
                throw new Error(result.error || 'Failed to auto fill PDF');
            }

            currentPDFData = result.pdfData;

            if (currentPDFUrl) {
                URL.revokeObjectURL(currentPDFUrl);
            }

            const blob = base64ToBlob(result.pdfData, 'application/pdf');
            currentPDFUrl = URL.createObjectURL(blob);
            pdfViewer.innerHTML = `<iframe src="${currentPDFUrl}"></iframe>`;

            showStatus(`Auto fill completed. ${result.filledFields} of ${result.totalFields} fields filled.`, 'success');

            fieldStats.innerHTML = `<span class="field-stats">${result.filledFields}/${result.totalFields} fields (auto)</span>`;

            // Enable download buttons
            downloadBtn.disabled = false;
            downloadCourtBtn.disabled = false;
            submitBtn.disabled = false;
        } catch (error) {
            console.error('Error in auto-fill:', error);
            showStatus('Error: ' + error.message, 'error');
        } finally {
            autoFillBtn.disabled = false;
        }
    }

    async function submitAdditionalJSON() {
        await fillPDF();
    }

    function downloadPDF() {
        if (!currentPDFData) {
            showStatus('No PDF available for download', 'error');
            return;
        }

        try {
            // Create blob from base64 data
            const blob = base64ToBlob(currentPDFData, 'application/pdf');
            const url = URL.createObjectURL(blob);
            
            // Create temporary download link
            const a = document.createElement('a');
            a.href = url;
            a.download = 'JurisDraft_Filing.pdf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // Cleanup
            URL.revokeObjectURL(url);
            
            showStatus('Download started!', 'success');
        } catch (error) {
            console.error('Download error:', error);
            showStatus('Download failed: ' + error.message, 'error');
        }
    }

    function downloadCourtReadyPDF() {
        if (!currentPDFData) {
            showStatus('No court-ready PDF available for download', 'error');
            return;
        }

        try {
            // Create blob from base64 data
            const blob = base64ToBlob(currentPDFData, 'application/pdf');
            const url = URL.createObjectURL(blob);
            
            // Create temporary download link
            const a = document.createElement('a');
            a.href = url;
            a.download = 'JurisDraft_Court_Ready.pdf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // Cleanup
            URL.revokeObjectURL(url);
            
            showStatus('Court-ready PDF download started!', 'success');
        } catch (error) {
            console.error('Download error:', error);
            showStatus('Download failed: ' + error.message, 'error');
        }
    }

    function base64ToBlob(base64, mimeType) {
        const byteCharacters = atob(base64);
        const byteArrays = [];

        for (let offset = 0; offset < byteCharacters.length; offset += 512) {
            const slice = byteCharacters.slice(offset, offset + 512);
            const byteNumbers = new Array(slice.length);
            
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }

        return new Blob(byteArrays, { type: mimeType });
    }

    function showStatus(message, type = 'info') {
        statusMessage.innerHTML = `<div class="status-box status-${type}">${message}</div>`;
    }

    window.addEventListener('beforeunload', () => {
        if (currentPDFUrl) {
            URL.revokeObjectURL(currentPDFUrl);
        }
    });

    fillBtn.addEventListener('click', fillPDF);
    submitBtn.addEventListener('click', submitAdditionalJSON);
    downloadBtn.addEventListener('click', downloadPDF);
    downloadCourtBtn.addEventListener('click', downloadCourtReadyPDF);
    autoFillBtn.addEventListener('click', autoFillPDF);

    loadTemplates();
    </script>
</body>
</html>
